package de.thm.xtend

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.emf.ecore.EClass
import java.util.List
import de.thm.exception.GenerationCanceledException
import org.eclipse.emf.ecore.EReference
import java.util.ArrayList
import org.sidiff.difference.symmetric.Change
import org.eclipse.core.resources.IFolder
import org.eclipse.core.resources.IFile
import java.io.InputStream
import java.io.ByteArrayInputStream
import org.eclipse.core.resources.IResource
import org.sidiff.difference.symmetric.AddObject
import org.sidiff.difference.symmetric.AddReference
import org.sidiff.difference.symmetric.AttributeValueChange
import org.sidiff.difference.symmetric.RemoveObject
import org.sidiff.difference.symmetric.RemoveReference
import org.sidiff.difference.symmetric.SymmetricDifference
import org.sidiff.difference.symmetric.SemanticChangeSet
import de.thm.evolvedb.mdde.Database_Schema
import de.thm.evolvedb.migration.Migration
import de.thm.evolvedb.migration.ResolvableOperator
import de.thm.evolvedb.migration.ProcessStatus
import de.thm.evolvedb.migration.ResolvableOperatorType
import java.util.Arrays
import de.thm.evolvedb.mdde.DataType
import de.thm.evolvedb.migration.PartiallyResolvable
import de.thm.evolvedb.migration.PartiallyResolvableOperatorType
import de.thm.evolvedb.migration.NotAutomaticallyResolvable
import de.thm.evolvedb.migration.NotAutomaticallyResolvableOperatorType

class SQLGenerator {

	// annotations
	/**
	 * Name for the AssociationClass annotation.
	 */
	final String ASSOCIATION_CLASS = "AssociationClass";
	/**
	 * Name for the AssociationEnd annotation.
	 */
	final String ASSOCIATION_END = "AssociationEnd";

	/**
	 * Name for the DisplayName annotation.
	 */
	final String DISPLAY_NAME = "DisplayName";

	boolean CHECK_CONSTRAINTS = false;

	/**
	 * The amount of work which has already been done.
	 */
	var int worked = 0;
	/**
	 * The total amount of work which has to be done.
	 */
	var int work = 75;

	/**
	 * Transactions that already have been visited.
	 */
	var List<SemanticChangeSet> processed;

	// For stats
	/**
	 * Count of generated bytes.
	 */
	var int generatedBytes = 0;
	/**
	 * Count of generated files.
	 */
	var int generatedFiles = 0;

	var long statements = 0;

	var long lineSeparators = 0;

	var long character = 0;

	public static String HISTORY_TABLE_NAME = "mdde_history";
	public static String TEMPORY_TABLE_NAME = "my_temp_id_table";

	// If the type is numeric, only digits are allowed.
	public var static List<DataType> numericTypes = Arrays.asList(DataType.BIGINT, DataType.DOUBLE, DataType.DECIMAL,
		DataType.DEC, DataType.FLOAT, DataType.INTEGER, DataType.MEDIUMINT, DataType.SMALLINT, DataType.TINYINT,
		DataType.BIGINT);

	public var static List<DataType> textTypes = Arrays.asList(DataType.CHAR, DataType.DATE, DataType.DATETIME,
		DataType.ENUM, DataType.LONGTEXT, DataType.MEDIUMTEXT, DataType.TEXT, DataType.VARCHAR, DataType.TINYTEXT,
		DataType.TIMESTAMP, DataType.TIME);

	/** 
	 * Generate the sql file.
	 */
	def String doGenerate(Resource resourceDifference, IProgressMonitor progressMonitor) {

		if (CHECK_CONSTRAINTS) {
			// check constraints
			// check if names are set
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass))) {
				for (a : e.EStructuralFeatures) {
					if (a.name === null) {
						throw new RuntimeException(a.toString)
					}
				}

			}

			// check if every AssociationClass are valid defined
			progressMonitor.subTask("Checking constraint: Whether every AssociationClasses are valid and sound");
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass)).filter[associationClass]) {
				var counter = 0
				for (EReference r : e.EReferences.filter[associationEnd]) {
					if (r.many) {
						throw new RuntimeException(
							"In AssociationClass " + e.name + " the AssociationEnd EReference " + r.name +
								" must not be many.");
					}
					counter++
				}
				if (counter != 2) {
					throw new RuntimeException("In AssociationClass " + e.name +
						" there must be two AssociationEnd annotated EReferences.");
				}
			}
			for (EReference a : resourceDifference.allContents.toIterable.filter(typeof(EReference)).filter [
				associationEnd
			]) {
				if (a.EContainingClass.associationClass == false) {
					throw new RuntimeException("In EClass " + a.EContainingClass.name +
						" are EReferences annotated with AssociationEnd, but the EClass is no AssociationClass.");
				}
			}
			makeProgressAndCheckCanceled(progressMonitor);

			// check if every EReference has EOpposite set
			progressMonitor.subTask("Checking constraint: Whether every EReference has an EOpposite");
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass))) {
				for (EReference r : e.EReferences) {
					if (r.EOpposite === null) {
						throw new RuntimeException("In EClass " + e.name + " the EReference " + r.name +
							" has no EOpposite set.");
					}
				}
			}
			makeProgressAndCheckCanceled(progressMonitor);

			// check for circle in DisplayName-Path
			progressMonitor.subTask("Checking constraint: No circle in DisplayName-path");
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass))) {
				checkCircleInDisplayNamePath(null, e, new ArrayList)
			}
			makeProgressAndCheckCanceled(progressMonitor);
		}

		// create filter package folder
//		var folder = project.getFolder("generatedFiles");
//		if (!folder.exists()) {
//			folder.create(true, true, null);
//		}
//		var DuplicateDatabaseSchema dds = new DuplicateDatabaseSchema
//		var dump = dds.duplicateDatabaseSchema(databaseSchemaA)
		var Migration migration = resourceDifference.allContents.findFirst[it instanceof Migration] as Migration
		var SymmetricDifference difference = migration.symmetricDifference

		var Resource modelA = difference.modelA
		var Resource modelB = difference.modelB

		var Database_Schema databaseSchemaA = modelA.allContents.
			findFirst[it instanceof Database_Schema] as Database_Schema

		var DuplicateDatabaseSchema dds = new DuplicateDatabaseSchema
		var dump = dds.duplicateDatabaseSchema(databaseSchemaA)

		// changes will be made in the schema described by the second model (modelB)
		var Database_Schema databaseSchemaB = modelB.allContents.
			findFirst[it instanceof Database_Schema] as Database_Schema

		var String content = '''
			USE «databaseSchemaB.name»;
			START TRANSACTION;
			
			-- Creates an history table for deleted and updated values
			«ColumnUtil.createDataCleansingTable(HISTORY_TABLE_NAME, databaseSchemaB)»
			
		''';

		if (processed === null)
			processed = new ArrayList;

		// Solve resolvables first
		var List<ResolvableOperator> resolvableOperators = migration.resolvableSMO
		// Solve partiallyResolvable second
		var List<PartiallyResolvable> partiallyResolvable = migration.partiallyResovableSMO
		// Solve NotAutomaticallyResolvable third
		var List<NotAutomaticallyResolvable> notAutomaticallyResolvable = migration.notAutimaticallyResolvable

		for (ResolvableOperator resolvable : resolvableOperators) {
			if (resolvable.processStatus == ProcessStatus.RESOLVED) {
				var c = processResolvableOperator(resolvable);
				content += c !== null ? c : "";
			}
		}

		var filteredpartiallyResolvable = partiallyResolvable.filter[processStatus == ProcessStatus.RESOLVED].toList
		// Execute changetype first
		var changeType = filteredpartiallyResolvable.filter [
			displayName === PartiallyResolvableOperatorType.SET_COLUMN_TYPE
		]
		for (PartiallyResolvable presolvable : changeType) {
			var c = processPartiallyResolvableOperator(presolvable);
			content += c !== null ? c : "";
		}
		filteredpartiallyResolvable.removeAll(changeType)

		for (PartiallyResolvable presolvable : filteredpartiallyResolvable) {
			var c = processPartiallyResolvableOperator(presolvable);
			content += c !== null ? c : "";
		}

		for (NotAutomaticallyResolvable naresolvable : notAutomaticallyResolvable) {
			if (naresolvable.processStatus == ProcessStatus.RESOLVED) {
				var c = processNotResolvableOperator(naresolvable);
				content += c !== null ? c : "";
			}
		}

		// resourceDifference.allContents.toIterable.filter(SemanticChangeSet)
		// process the changes in the correct order. 
//		for (var i = 0; i <= 5; i++) {
//			val index = i;
//			for (e : semanticChangeSets.filter[refinementLevel == index]) {
//				var c = processSemanticChangeSet(e);
//				content += c !== null ? c : "";
//			}
//
//		}
//		createFile(folder, "dump.sql", true, dump, progressMonitor);
		// createFile(folder, "test.sql", true, content, progressMonitor);
		content += '''
			COMMIT;
			-- If executing the script fails, we suggest a rollback.
		'''
		return content;

	// fsa.generateFile("\test.sql", content);
	}

	// The order doesn't matter.
	def String processResolvableOperator(ResolvableOperator resolvableOperator) {
		switch (resolvableOperator.displayName) {
			case ResolvableOperatorType.CREATE_TABLE: {
				return CREATE_ELEMENT._CREATE_Table_IN_Database_Schema_entites(resolvableOperator);
			}
			case ResolvableOperatorType.RENAME_TABLE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_NamedElement_Name(resolvableOperator);
			}
			case ResolvableOperatorType.RENAME_COLUMN: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_NamedElement_Name(resolvableOperator);
			}
			case ResolvableOperatorType.CREATE_COLUMN: {
				return CREATE_ELEMENT._CREATE_Column_IN_Table_columns(resolvableOperator);
			}
			case ResolvableOperatorType.CREATE_FOREIGN_KEY: {
				return CREATE_ELEMENT._CREATE_ForeignKey_IN_Table_columns(resolvableOperator);
			}
			case ResolvableOperatorType.CREATE_PRIMARY_KEY: {
				return CREATE_ELEMENT._CREATE_PrimaryKey_IN_Table_columns(resolvableOperator);
			}
			case ResolvableOperatorType.CHANGE_REFERENTIAL_ACTION: {
				return SET_ATTRIBUTE._CHANGE_Literal_ForeignKey(resolvableOperator);
			}
			case ResolvableOperatorType.SET_COLUMN_DEFAULT_VALUE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_DefaultValue(resolvableOperator);
			}
			default: {
				println("Operator does not exists")
			}
		}
	}

	// The operator order does matter
	def String processPartiallyResolvableOperator(PartiallyResolvable partiallyResolvable) {

		switch (partiallyResolvable.displayName) {
			case PartiallyResolvableOperatorType.SET_COLUMN_SIZE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Size(partiallyResolvable);
			}
			case PartiallyResolvableOperatorType.SET_COLUMN_UNIQUE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Unique(partiallyResolvable);
			}
			case PartiallyResolvableOperatorType.SET_COLUMN_TYPE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Type(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_COLUMN: {
				return DELETE_ELEMENT._DELETE_Column_IN_Table_columns(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_FOREIGN_KEY: {
				return DELETE_ELEMENT._DELETE_ForeignKey_IN_Table_columns(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_TABLE: {
				return DELETE_ELEMENT._DELETE_Table_IN_Database_Schema_entites(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_PRIMARY_KEY: {
				return DELETE_ELEMENT._DELETE_PrimaryKey_IN_Table_columns(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_1N_INTO_NM: {
				return ComplexChanges._CHANGE_1N_INTO_NM(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_1N_INTO_NM_MOVE: {
				return ComplexChanges._CHANGE_1N_INTO_NM_MOVE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_1N_INTO_NM_PRESERVE: {
				return ComplexChanges._CHANGE_1N_INTO_NM_PRESERVE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_NM_INTO_1N: {
				return ComplexChanges._CHANGE_NM_INTO_1N(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_NM_INTO_1N_PRESERVE: {
				return ComplexChanges._CHANGE_NM_INTO_1N_PRESERVE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.SET_COLUMN_TYPE_AND_SIZE: {
				return SET_ATTRIBUTE._SET_COLUMN_TYPE_AND_SIZE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.SET_COLUMN_NOT_NULL: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_NotNull(partiallyResolvable);

			}
			default: {
				"-- Operator does not exists"
			}
		}

	}

	def String processNotResolvableOperator(NotAutomaticallyResolvable notAutomaticallyResolvable) {
		switch (notAutomaticallyResolvable.displayName) {
			case NotAutomaticallyResolvableOperatorType.MOVE_COLUMN: {
				return MOVE_ELEMENT._MOVE_Column_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
			}
			case NotAutomaticallyResolvableOperatorType.MOVE_FOREIGN_KEY: {
				return MOVE_ELEMENT._MOVE_ForeignKey_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
			}
			case NotAutomaticallyResolvableOperatorType.MOVE_PRIMARY_KEY: {
				return MOVE_ELEMENT._MOVE_PrimaryKey_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
			}
			
			case NotAutomaticallyResolvableOperatorType.JOIN_TABLE: {
				return ComplexChanges._JOIN_TABLE(notAutomaticallyResolvable);
			}
			
			default: {
				println("Operator does not exists")
			}
		}

	}

	/**
	 * Switch case method to identify the different semantic change sets.
	 */
	def String processSemanticChangeSet(SemanticChangeSet set) {

		switch (set.name) {
			// SET
			case 'SET_ATTRIBUTE_PrimaryKey_PrimaryKey': {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_PrimaryKey_PrimaryKey(set);

			}
			case 'SET_ATTRIBUTE_ForeignKey_PrimaryForeignKey': {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_ForeignKey_PrimaryForeignKey(set);

			}
			case 'SET_ATTRIBUTE_Column_AutoIncrement': {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_AutoIncrement(set);
			}
		// MOVE 
		}

		return "";

	}

	/** 
	 * SMO change table name
	 * */
	def String change_NamedElement_Name(SemanticChangeSet set) {
	}

	def dispatch String processChangeOperation(AddObject object) {
	}

	def dispatch String processChangeOperation(AddReference object) {
	}

	def dispatch String processChangeOperation(AttributeValueChange object) {
	}

	def dispatch String processChangeOperation(RemoveObject object) {
	}

	def dispatch String processChangeOperation(RemoveReference object) {
	}

	/**
	 * Verarbeitet eine Transaktion und gibt den Code für die SQL Datei als String zurueck.
	 */
	def String processChange(SemanticChangeSet semanticChangeSet) {
		if (processed.contains(semanticChangeSet))
			return "";
		var String content = "";
//		for (t : change.required) {
//			content += processTransaction(t);
//
//		}
		println("SymmetricDifference" + semanticChangeSet.description)

		for (Change change : semanticChangeSet.changes) {
			content += change.processChangeOperation
		}

		processed.add(semanticChangeSet);
		return content;

	}

	def String javaToSQLType(String type) {
		switch (type) {
			case "java.lang.String": {
				return "varchar(255)"
			}
			case "java.lang.Integer": {
				return "bigint(20)"
			}
			case "java.lang.Long": {
				return "bigint(20)"
			}
			case "long": {
				return "bigint(20)"
			}
			case "java.lang.Boolean": {
				return "tinyint(1)"
			}
			case "java.util.Date": {
				return "datetime"
			}
			case "byte[]": {
				return "longblob"
			}
			default: {
				return "varchar(255)" // TODO Enum usw.
			}
		}
	}

	def void checkCircleInDisplayNamePath(EClass current, EClass start, List<EClass> path) {
		if (start.equals(current)) {
			throw new RuntimeException(
				"Circle detected in DisplayName-path starting in EClass: " + current.name + ". Path is: " + path)
		}
		if (current !== null) {
			path.add(current)
		}
		var EClass tmp = current
		if (tmp === null) {
			tmp = start
		}
		for (a : tmp.EAllReferences.filter[EAnnotations.exists[source.equals(DISPLAY_NAME)]]) {
			checkCircleInDisplayNamePath(a.EReferenceType, start, path)
		}
	}

	def void makeProgressAndCheckCanceled(IProgressMonitor monitor) {
		if (monitor.canceled) {
			throw new GenerationCanceledException
		}
		monitor.worked(1)
		worked++
		var int done = ((worked as double / work as double) * 100.0) as int
		monitor.taskName = "Generating code... " + done + "%"
	}

	/**
	 * Returns {@code true} if the given EClass is annotated with the {@link #ASSOCIATION_CLASS} annotation. In this case, the given EClass is an association class.
	 */
	def boolean isAssociationClass(EClass e) {
		return e.EAnnotations.exists[source.equals(ASSOCIATION_CLASS)]
	}

	def boolean isAssociationEnd(EReference ref) {
		return ref.EAnnotations.exists[source.equals(ASSOCIATION_END)]
	}

	/**
	 * Creates a file of the given content in the given folder. If the folder does not exist, it will be created.
	 */
	def void createFile(IFolder folder, String fileName, boolean overrideFile, CharSequence content,
		IProgressMonitor progressMonitor) {
		if (progressMonitor.canceled) {
			throw new GenerationCanceledException
		}

		if (!folder.exists()) {
			folder.create(true, true, null);
		}

		var IFile iFile = folder.getFile(fileName);

		if (overrideFile == false && iFile.exists) {
			return;
		}
		if (!iFile.exists) {
			iFile.create(null, true, null);
		}

		// count character
		character += content.length

		// process the code
		var String formattedCode
//		if (fileName.endsWith(".java")) {
//			// organize imports
//			// count for stats
//			val char semicolon = ';'
//			val contentString = content.toString
//			val char[] charArray = contentString.toCharArray
//			for (char c : charArray) {
//				if (c == semicolon) {
//					statements++
//				}
//			}
//			lineSeparators += contentString.split(System.lineSeparator).length
		// TODO im not generating java code
		// var String sourceWithImports = importFinder.getWithImports(content.toString)
		// format the java code
		// formattedCode = JavaFormatter.format(sourceWithImports)
//		} else if (fileName.endsWith(".xml")) {
//			// format the xml code
//			formattedCode = XmlFormatter.format(content.toString)
//		}
		var byte[] bytes
		if (formattedCode !== null) { // has the code been formatted?
			bytes = formattedCode.getBytes()
		} else { // code could not be formatted
			bytes = content.toString.bytes
			System.err.println("File " + fileName + " could not be formatted.")
		}
		// save the file
		var InputStream source = new ByteArrayInputStream(bytes)
		generatedFiles++
		generatedBytes += bytes.size
		iFile.setContents(source, IResource.FORCE, null)
	}

}
