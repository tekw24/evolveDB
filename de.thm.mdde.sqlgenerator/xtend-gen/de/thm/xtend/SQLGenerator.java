package de.thm.xtend;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import de.thm.evolvedb.mdde.DataType;
import de.thm.evolvedb.mdde.Database_Schema;
import de.thm.evolvedb.migration.Migration;
import de.thm.evolvedb.migration.NotAutomaticallyResolvable;
import de.thm.evolvedb.migration.NotAutomaticallyResolvableOperatorType;
import de.thm.evolvedb.migration.PartiallyResolvable;
import de.thm.evolvedb.migration.PartiallyResolvableOperatorType;
import de.thm.evolvedb.migration.ProcessStatus;
import de.thm.evolvedb.migration.ResolvableOperator;
import de.thm.evolvedb.migration.ResolvableOperatorType;
import de.thm.exception.GenerationCanceledException;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.CollectionExtensions;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.sidiff.difference.symmetric.AddObject;
import org.sidiff.difference.symmetric.AddReference;
import org.sidiff.difference.symmetric.AttributeValueChange;
import org.sidiff.difference.symmetric.Change;
import org.sidiff.difference.symmetric.RemoveObject;
import org.sidiff.difference.symmetric.RemoveReference;
import org.sidiff.difference.symmetric.SemanticChangeSet;
import org.sidiff.difference.symmetric.SymmetricDifference;

@SuppressWarnings("all")
public class SQLGenerator {
  /**
   * Name for the AssociationClass annotation.
   */
  private final String ASSOCIATION_CLASS = "AssociationClass";

  /**
   * Name for the AssociationEnd annotation.
   */
  private final String ASSOCIATION_END = "AssociationEnd";

  /**
   * Name for the DisplayName annotation.
   */
  private final String DISPLAY_NAME = "DisplayName";

  private boolean CHECK_CONSTRAINTS = false;

  /**
   * The amount of work which has already been done.
   */
  private int worked = 0;

  /**
   * The total amount of work which has to be done.
   */
  private int work = 75;

  /**
   * Transactions that already have been visited.
   */
  private List<SemanticChangeSet> processed;

  /**
   * Count of generated bytes.
   */
  private int generatedBytes = 0;

  /**
   * Count of generated files.
   */
  private int generatedFiles = 0;

  private long statements = 0;

  private long lineSeparators = 0;

  private long character = 0;

  public static String HISTORY_TABLE_NAME = "mdde_history";

  public static String TEMPORY_TABLE_NAME = "my_temp_id_table";

  public static List<DataType> numericTypes = Arrays.<DataType>asList(DataType.BIGINT, DataType.DOUBLE, DataType.DECIMAL, 
    DataType.DEC, DataType.FLOAT, DataType.INTEGER, DataType.MEDIUMINT, DataType.SMALLINT, DataType.TINYINT, 
    DataType.BIGINT);

  public static List<DataType> textTypes = Arrays.<DataType>asList(DataType.CHAR, DataType.DATE, DataType.DATETIME, 
    DataType.ENUM, DataType.LONGTEXT, DataType.MEDIUMTEXT, DataType.TEXT, DataType.VARCHAR, DataType.TINYTEXT, 
    DataType.TIMESTAMP, DataType.TIME);

  /**
   * Generate the sql file.
   */
  public String doGenerate(final Resource resourceDifference, final IProgressMonitor progressMonitor) {
    if (this.CHECK_CONSTRAINTS) {
      Iterable<EClass> _filter = Iterables.<EClass>filter(IteratorExtensions.<EObject>toIterable(resourceDifference.getAllContents()), EClass.class);
      for (final EClass e : _filter) {
        EList<EStructuralFeature> _eStructuralFeatures = e.getEStructuralFeatures();
        for (final EStructuralFeature a : _eStructuralFeatures) {
          String _name = a.getName();
          boolean _tripleEquals = (_name == null);
          if (_tripleEquals) {
            String _string = a.toString();
            throw new RuntimeException(_string);
          }
        }
      }
      progressMonitor.subTask("Checking constraint: Whether every AssociationClasses are valid and sound");
      final Function1<EClass, Boolean> _function = (EClass it) -> {
        return Boolean.valueOf(this.isAssociationClass(it));
      };
      Iterable<EClass> _filter_1 = IterableExtensions.<EClass>filter(Iterables.<EClass>filter(IteratorExtensions.<EObject>toIterable(resourceDifference.getAllContents()), EClass.class), _function);
      for (final EClass e_1 : _filter_1) {
        {
          int counter = 0;
          final Function1<EReference, Boolean> _function_1 = (EReference it) -> {
            return Boolean.valueOf(this.isAssociationEnd(it));
          };
          Iterable<EReference> _filter_2 = IterableExtensions.<EReference>filter(e_1.getEReferences(), _function_1);
          for (final EReference r : _filter_2) {
            {
              boolean _isMany = r.isMany();
              if (_isMany) {
                String _name_1 = e_1.getName();
                String _plus = ("In AssociationClass " + _name_1);
                String _plus_1 = (_plus + " the AssociationEnd EReference ");
                String _name_2 = r.getName();
                String _plus_2 = (_plus_1 + _name_2);
                String _plus_3 = (_plus_2 + 
                  " must not be many.");
                throw new RuntimeException(_plus_3);
              }
              counter++;
            }
          }
          if ((counter != 2)) {
            String _name_1 = e_1.getName();
            String _plus = ("In AssociationClass " + _name_1);
            String _plus_1 = (_plus + 
              " there must be two AssociationEnd annotated EReferences.");
            throw new RuntimeException(_plus_1);
          }
        }
      }
      final Function1<EReference, Boolean> _function_1 = (EReference it) -> {
        return Boolean.valueOf(this.isAssociationEnd(it));
      };
      Iterable<EReference> _filter_2 = IterableExtensions.<EReference>filter(Iterables.<EReference>filter(IteratorExtensions.<EObject>toIterable(resourceDifference.getAllContents()), EReference.class), _function_1);
      for (final EReference a_1 : _filter_2) {
        boolean _isAssociationClass = this.isAssociationClass(a_1.getEContainingClass());
        boolean _equals = (_isAssociationClass == false);
        if (_equals) {
          String _name_1 = a_1.getEContainingClass().getName();
          String _plus = ("In EClass " + _name_1);
          String _plus_1 = (_plus + 
            " are EReferences annotated with AssociationEnd, but the EClass is no AssociationClass.");
          throw new RuntimeException(_plus_1);
        }
      }
      this.makeProgressAndCheckCanceled(progressMonitor);
      progressMonitor.subTask("Checking constraint: Whether every EReference has an EOpposite");
      Iterable<EClass> _filter_3 = Iterables.<EClass>filter(IteratorExtensions.<EObject>toIterable(resourceDifference.getAllContents()), EClass.class);
      for (final EClass e_2 : _filter_3) {
        EList<EReference> _eReferences = e_2.getEReferences();
        for (final EReference r : _eReferences) {
          EReference _eOpposite = r.getEOpposite();
          boolean _tripleEquals_1 = (_eOpposite == null);
          if (_tripleEquals_1) {
            String _name_2 = e_2.getName();
            String _plus_2 = ("In EClass " + _name_2);
            String _plus_3 = (_plus_2 + " the EReference ");
            String _name_3 = r.getName();
            String _plus_4 = (_plus_3 + _name_3);
            String _plus_5 = (_plus_4 + 
              " has no EOpposite set.");
            throw new RuntimeException(_plus_5);
          }
        }
      }
      this.makeProgressAndCheckCanceled(progressMonitor);
      progressMonitor.subTask("Checking constraint: No circle in DisplayName-path");
      Iterable<EClass> _filter_4 = Iterables.<EClass>filter(IteratorExtensions.<EObject>toIterable(resourceDifference.getAllContents()), EClass.class);
      for (final EClass e_3 : _filter_4) {
        ArrayList<EClass> _arrayList = new ArrayList<EClass>();
        this.checkCircleInDisplayNamePath(null, e_3, _arrayList);
      }
      this.makeProgressAndCheckCanceled(progressMonitor);
    }
    final Function1<EObject, Boolean> _function_2 = (EObject it) -> {
      return Boolean.valueOf((it instanceof Migration));
    };
    EObject _findFirst = IteratorExtensions.<EObject>findFirst(resourceDifference.getAllContents(), _function_2);
    Migration migration = ((Migration) _findFirst);
    SymmetricDifference difference = migration.getSymmetricDifference();
    Resource modelA = difference.getModelA();
    Resource modelB = difference.getModelB();
    final Function1<EObject, Boolean> _function_3 = (EObject it) -> {
      return Boolean.valueOf((it instanceof Database_Schema));
    };
    EObject _findFirst_1 = IteratorExtensions.<EObject>findFirst(modelA.getAllContents(), _function_3);
    Database_Schema databaseSchemaA = ((Database_Schema) _findFirst_1);
    DuplicateDatabaseSchema dds = new DuplicateDatabaseSchema();
    String dump = dds.duplicateDatabaseSchema(databaseSchemaA);
    final Function1<EObject, Boolean> _function_4 = (EObject it) -> {
      return Boolean.valueOf((it instanceof Database_Schema));
    };
    EObject _findFirst_2 = IteratorExtensions.<EObject>findFirst(modelB.getAllContents(), _function_4);
    Database_Schema databaseSchemaB = ((Database_Schema) _findFirst_2);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("USE �databaseSchemaB.name�;");
    _builder.newLine();
    _builder.append("START TRANSACTION;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("-- Creates an history table for deleted and updated values");
    _builder.newLine();
    _builder.append("�ColumnUtil.createDataCleansingTable(HISTORY_TABLE_NAME, databaseSchemaB)�");
    _builder.newLine();
    _builder.newLine();
    String content = _builder.toString();
    if ((this.processed == null)) {
      ArrayList<SemanticChangeSet> _arrayList_1 = new ArrayList<SemanticChangeSet>();
      this.processed = _arrayList_1;
    }
    List<ResolvableOperator> resolvableOperators = migration.getResolvableSMO();
    List<PartiallyResolvable> partiallyResolvable = migration.getPartiallyResovableSMO();
    List<NotAutomaticallyResolvable> notAutomaticallyResolvable = migration.getNotAutimaticallyResolvable();
    for (final ResolvableOperator resolvable : resolvableOperators) {
      ProcessStatus _processStatus = resolvable.getProcessStatus();
      boolean _equals_1 = Objects.equal(_processStatus, ProcessStatus.RESOLVED);
      if (_equals_1) {
        String c = this.processResolvableOperator(resolvable);
        String _content = content;
        String _xifexpression = null;
        if ((c != null)) {
          _xifexpression = c;
        } else {
          _xifexpression = "";
        }
        content = (_content + _xifexpression);
      }
    }
    final Function1<PartiallyResolvable, Boolean> _function_5 = (PartiallyResolvable it) -> {
      ProcessStatus _processStatus_1 = it.getProcessStatus();
      return Boolean.valueOf(Objects.equal(_processStatus_1, ProcessStatus.RESOLVED));
    };
    List<PartiallyResolvable> filteredpartiallyResolvable = IterableExtensions.<PartiallyResolvable>toList(IterableExtensions.<PartiallyResolvable>filter(partiallyResolvable, _function_5));
    final Function1<PartiallyResolvable, Boolean> _function_6 = (PartiallyResolvable it) -> {
      PartiallyResolvableOperatorType _displayName = it.getDisplayName();
      return Boolean.valueOf((_displayName == PartiallyResolvableOperatorType.SET_COLUMN_TYPE));
    };
    Iterable<PartiallyResolvable> changeType = IterableExtensions.<PartiallyResolvable>filter(filteredpartiallyResolvable, _function_6);
    for (final PartiallyResolvable presolvable : changeType) {
      {
        String c_1 = this.processPartiallyResolvableOperator(presolvable);
        String _content_1 = content;
        String _xifexpression_1 = null;
        if ((c_1 != null)) {
          _xifexpression_1 = c_1;
        } else {
          _xifexpression_1 = "";
        }
        content = (_content_1 + _xifexpression_1);
      }
    }
    CollectionExtensions.<PartiallyResolvable>removeAll(filteredpartiallyResolvable, changeType);
    for (final PartiallyResolvable presolvable_1 : filteredpartiallyResolvable) {
      {
        String c_1 = this.processPartiallyResolvableOperator(presolvable_1);
        String _content_1 = content;
        String _xifexpression_1 = null;
        if ((c_1 != null)) {
          _xifexpression_1 = c_1;
        } else {
          _xifexpression_1 = "";
        }
        content = (_content_1 + _xifexpression_1);
      }
    }
    for (final NotAutomaticallyResolvable naresolvable : notAutomaticallyResolvable) {
      ProcessStatus _processStatus_1 = naresolvable.getProcessStatus();
      boolean _equals_2 = Objects.equal(_processStatus_1, ProcessStatus.RESOLVED);
      if (_equals_2) {
        String c_1 = this.processNotResolvableOperator(naresolvable);
        String _content_1 = content;
        String _xifexpression_1 = null;
        if ((c_1 != null)) {
          _xifexpression_1 = c_1;
        } else {
          _xifexpression_1 = "";
        }
        content = (_content_1 + _xifexpression_1);
      }
    }
    String _content_2 = content;
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("COMMIT;");
    _builder_1.newLine();
    _builder_1.append("-- If executing the script fails, we suggest a rollback.");
    _builder_1.newLine();
    content = (_content_2 + _builder_1);
    return content;
  }

  public String processResolvableOperator(final ResolvableOperator resolvableOperator) {
    String _switchResult = null;
    ResolvableOperatorType _displayName = resolvableOperator.getDisplayName();
    if (_displayName != null) {
      switch (_displayName) {
        case CREATE_TABLE:
          return CREATE_ELEMENT._CREATE_Table_IN_Database_Schema_entites(resolvableOperator);
        case RENAME_TABLE:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_NamedElement_Name(resolvableOperator);
        case RENAME_COLUMN:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_NamedElement_Name(resolvableOperator);
        case CREATE_COLUMN:
          return CREATE_ELEMENT._CREATE_Column_IN_Table_columns(resolvableOperator);
        case CREATE_FOREIGN_KEY:
          return CREATE_ELEMENT._CREATE_ForeignKey_IN_Table_columns(resolvableOperator);
        case CREATE_PRIMARY_KEY:
          return CREATE_ELEMENT._CREATE_PrimaryKey_IN_Table_columns(resolvableOperator);
        case CHANGE_REFERENTIAL_ACTION:
          return SET_ATTRIBUTE._CHANGE_Literal_ForeignKey(resolvableOperator);
        case SET_COLUMN_DEFAULT_VALUE:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_DefaultValue(resolvableOperator);
        default:
          _switchResult = InputOutput.<String>println("Operator does not exists");
          break;
      }
    } else {
      _switchResult = InputOutput.<String>println("Operator does not exists");
    }
    return _switchResult;
  }

  public String processPartiallyResolvableOperator(final PartiallyResolvable partiallyResolvable) {
    String _switchResult = null;
    PartiallyResolvableOperatorType _displayName = partiallyResolvable.getDisplayName();
    if (_displayName != null) {
      switch (_displayName) {
        case SET_COLUMN_SIZE:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Size(partiallyResolvable);
        case SET_COLUMN_UNIQUE:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Unique(partiallyResolvable);
        case SET_COLUMN_TYPE:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Type(partiallyResolvable);
        case DELETE_COLUMN:
          return DELETE_ELEMENT._DELETE_Column_IN_Table_columns(partiallyResolvable);
        case DELETE_FOREIGN_KEY:
          return DELETE_ELEMENT._DELETE_ForeignKey_IN_Table_columns(partiallyResolvable);
        case DELETE_TABLE:
          return DELETE_ELEMENT._DELETE_Table_IN_Database_Schema_entites(partiallyResolvable);
        case DELETE_PRIMARY_KEY:
          return DELETE_ELEMENT._DELETE_PrimaryKey_IN_Table_columns(partiallyResolvable);
        case CHANGE_1N_INTO_NM:
          return ComplexChanges._CHANGE_1N_INTO_NM(partiallyResolvable);
        case CHANGE_1N_INTO_NM_PRESERVE:
          return ComplexChanges._CHANGE_1N_INTO_NM_PRESERVE(partiallyResolvable);
        case CHANGE_NM_INTO_1N:
          return ComplexChanges._CHANGE_NM_INTO_1N(partiallyResolvable);
        case CHANGE_NM_INTO_1N_PRESERVE:
          return ComplexChanges._CHANGE_NM_INTO_1N_PRESERVE(partiallyResolvable);
        case SET_COLUMN_TYPE_AND_SIZE:
          return SET_ATTRIBUTE._SET_COLUMN_TYPE_AND_SIZE(partiallyResolvable);
        case SET_COLUMN_NOT_NULL:
          return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_NotNull(partiallyResolvable);
        default:
          _switchResult = InputOutput.<String>println("Operator does not exists");
          break;
      }
    } else {
      _switchResult = InputOutput.<String>println("Operator does not exists");
    }
    return _switchResult;
  }

  public String processNotResolvableOperator(final NotAutomaticallyResolvable notAutomaticallyResolvable) {
    String _switchResult = null;
    NotAutomaticallyResolvableOperatorType _displayName = notAutomaticallyResolvable.getDisplayName();
    if (_displayName != null) {
      switch (_displayName) {
        case MOVE_COLUMN:
          return MOVE_ELEMENT._MOVE_Column_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
        case MOVE_FOREIGN_KEY:
          return MOVE_ELEMENT._MOVE_ForeignKey_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
        case MOVE_PRIMARY_KEY:
          return MOVE_ELEMENT._MOVE_PrimaryKey_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
        case JOIN_TABLE:
          return ComplexChanges._JOIN_TABLE(notAutomaticallyResolvable);
        default:
          _switchResult = InputOutput.<String>println("Operator does not exists");
          break;
      }
    } else {
      _switchResult = InputOutput.<String>println("Operator does not exists");
    }
    return _switchResult;
  }

  /**
   * Switch case method to identify the different semantic change sets.
   */
  public String processSemanticChangeSet(final SemanticChangeSet set) {
    String _name = set.getName();
    if (_name != null) {
      switch (_name) {
        case "SET_ATTRIBUTE_PrimaryKey_PrimaryKey":
          return SET_ATTRIBUTE._SET_ATTRIBUTE_PrimaryKey_PrimaryKey(set);
        case "SET_ATTRIBUTE_ForeignKey_PrimaryForeignKey":
          return SET_ATTRIBUTE._SET_ATTRIBUTE_ForeignKey_PrimaryForeignKey(set);
        case "SET_ATTRIBUTE_Column_AutoIncrement":
          return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_AutoIncrement(set);
      }
    }
    return "";
  }

  /**
   * SMO change table name
   */
  public String change_NamedElement_Name(final SemanticChangeSet set) {
    return null;
  }

  protected String _processChangeOperation(final AddObject object) {
    return null;
  }

  protected String _processChangeOperation(final AddReference object) {
    return null;
  }

  protected String _processChangeOperation(final AttributeValueChange object) {
    return null;
  }

  protected String _processChangeOperation(final RemoveObject object) {
    return null;
  }

  protected String _processChangeOperation(final RemoveReference object) {
    return null;
  }

  /**
   * Verarbeitet eine Transaktion und gibt den Code f�r die SQL Datei als String zur�ck.
   */
  public String processChange(final SemanticChangeSet semanticChangeSet) {
    boolean _contains = this.processed.contains(semanticChangeSet);
    if (_contains) {
      return "";
    }
    String content = "";
    String _description = semanticChangeSet.getDescription();
    String _plus = ("SymmetricDifference" + _description);
    InputOutput.<String>println(_plus);
    EList<Change> _changes = semanticChangeSet.getChanges();
    for (final Change change : _changes) {
      String _content = content;
      String _processChangeOperation = this.processChangeOperation(change);
      content = (_content + _processChangeOperation);
    }
    this.processed.add(semanticChangeSet);
    return content;
  }

  public String javaToSQLType(final String type) {
    if (type != null) {
      switch (type) {
        case "java.lang.String":
          return "varchar(255)";
        case "java.lang.Integer":
          return "bigint(20)";
        case "java.lang.Long":
          return "bigint(20)";
        case "long":
          return "bigint(20)";
        case "java.lang.Boolean":
          return "tinyint(1)";
        case "java.util.Date":
          return "datetime";
        case "byte[]":
          return "longblob";
        default:
          return "varchar(255)";
      }
    } else {
      return "varchar(255)";
    }
  }

  public void checkCircleInDisplayNamePath(final EClass current, final EClass start, final List<EClass> path) {
    boolean _equals = start.equals(current);
    if (_equals) {
      String _name = current.getName();
      String _plus = ("Circle detected in DisplayName-path starting in EClass: " + _name);
      String _plus_1 = (_plus + ". Path is: ");
      String _plus_2 = (_plus_1 + path);
      throw new RuntimeException(_plus_2);
    }
    if ((current != null)) {
      path.add(current);
    }
    EClass tmp = current;
    if ((tmp == null)) {
      tmp = start;
    }
    final Function1<EReference, Boolean> _function = (EReference it) -> {
      final Function1<EAnnotation, Boolean> _function_1 = (EAnnotation it_1) -> {
        return Boolean.valueOf(it_1.getSource().equals(this.DISPLAY_NAME));
      };
      return Boolean.valueOf(IterableExtensions.<EAnnotation>exists(it.getEAnnotations(), _function_1));
    };
    Iterable<EReference> _filter = IterableExtensions.<EReference>filter(tmp.getEAllReferences(), _function);
    for (final EReference a : _filter) {
      this.checkCircleInDisplayNamePath(a.getEReferenceType(), start, path);
    }
  }

  public void makeProgressAndCheckCanceled(final IProgressMonitor monitor) {
    boolean _isCanceled = monitor.isCanceled();
    if (_isCanceled) {
      throw new GenerationCanceledException();
    }
    monitor.worked(1);
    this.worked++;
    int done = ((int) ((((double) this.worked) / ((double) this.work)) * 100.0));
    monitor.setTaskName((("Generating code... " + Integer.valueOf(done)) + "%"));
  }

  /**
   * Returns {@code true} if the given EClass is annotated with the {@link #ASSOCIATION_CLASS} annotation. In this case, the given EClass is an association class.
   */
  public boolean isAssociationClass(final EClass e) {
    final Function1<EAnnotation, Boolean> _function = (EAnnotation it) -> {
      return Boolean.valueOf(it.getSource().equals(this.ASSOCIATION_CLASS));
    };
    return IterableExtensions.<EAnnotation>exists(e.getEAnnotations(), _function);
  }

  public boolean isAssociationEnd(final EReference ref) {
    final Function1<EAnnotation, Boolean> _function = (EAnnotation it) -> {
      return Boolean.valueOf(it.getSource().equals(this.ASSOCIATION_END));
    };
    return IterableExtensions.<EAnnotation>exists(ref.getEAnnotations(), _function);
  }

  /**
   * Creates a file of the given content in the given folder. If the folder does not exist, it will be created.
   */
  public void createFile(final IFolder folder, final String fileName, final boolean overrideFile, final CharSequence content, final IProgressMonitor progressMonitor) {
    try {
      boolean _isCanceled = progressMonitor.isCanceled();
      if (_isCanceled) {
        throw new GenerationCanceledException();
      }
      boolean _exists = folder.exists();
      boolean _not = (!_exists);
      if (_not) {
        folder.create(true, true, null);
      }
      IFile iFile = folder.getFile(fileName);
      if (((overrideFile == false) && iFile.exists())) {
        return;
      }
      boolean _exists_1 = iFile.exists();
      boolean _not_1 = (!_exists_1);
      if (_not_1) {
        iFile.create(null, true, null);
      }
      long _character = this.character;
      int _length = content.length();
      this.character = (_character + _length);
      String formattedCode = null;
      byte[] bytes = null;
      if ((formattedCode != null)) {
        bytes = formattedCode.getBytes();
      } else {
        bytes = content.toString().getBytes();
        System.err.println((("File " + fileName) + " could not be formatted."));
      }
      InputStream source = new ByteArrayInputStream(bytes);
      this.generatedFiles++;
      int _generatedBytes = this.generatedBytes;
      final byte[] _converted_bytes = (byte[])bytes;
      int _size = ((List<Byte>)Conversions.doWrapArray(_converted_bytes)).size();
      this.generatedBytes = (_generatedBytes + _size);
      iFile.setContents(source, IResource.FORCE, null);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  public String processChangeOperation(final Change object) {
    if (object instanceof AddObject) {
      return _processChangeOperation((AddObject)object);
    } else if (object instanceof AddReference) {
      return _processChangeOperation((AddReference)object);
    } else if (object instanceof AttributeValueChange) {
      return _processChangeOperation((AttributeValueChange)object);
    } else if (object instanceof RemoveObject) {
      return _processChangeOperation((RemoveObject)object);
    } else if (object instanceof RemoveReference) {
      return _processChangeOperation((RemoveReference)object);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(object).toString());
    }
  }
}
